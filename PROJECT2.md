# 2024 Проект 2: Task solver

В этом проекте вам предстоит создать сервер для обработки задач, принимаемых от клиентов через HTTP запросы. Ваш сервер будет получать задачи от клиентов, отслеживать их выполнение и выдавать результаты.

Проект представлен в двух версиях: базовая версия оценивается в 2.5 балла, а усложненная версия — в 3.5 балла (2.5 балла + 1 дополнительный балл). Подробности о расширенной версии находятся в отдельном разделе ниже.

Enjoy 🙂

## Что подразумевается под Task solver-ом?

Сервер для выполнения задач должен использовать ограниченное количество потоков, чтобы эффективно распараллеливать обработку задач (чем-то похоже на задачу ThreadPool из домашней работы threads). Если бы для каждой задачи создавался отдельный поток, это быстро привело бы к падению производительности, когда количество потоков превысило бы количество ядер процессора. Сервер будет распределять задачи из общей очереди между рабочими процессами (worker), каждый из которых будет выполнять задачу на отдельном потоке и по завершении ее выполнения -- запрашивать следующую. Так рабочие всегда будут заняты задачами из очереди, без создания лишних потоков.

```
Клиент --HTTP--> Сервер (очередь задач) ---> Worker
                 |                      |
                 |-----> Задача -----> Worker
                 | <--- Завершение <--- Worker

```

## Что требуется от вашей программы?

Программа должна открыть HTTP-сервер, принимающий соединения по указанному адресу и порту, и обрабатывать запросы от клиентов. Клиенты смогут взаимодействовать с сервером через его HTTP API:

#### Создание задач
Клиенты отправляют HTTP POST запрос на `/create_task` с телом сообщения в следующем формате:

```json
{"type": "python/bin", "file": "...", "args": "..."}
```
где:
- `type` — тип задачи, либо python для скриптов Python, либо bin для бинарных файлов.
- `file` — код программы на Python или бинарный файл, закодированный в base64.
- `args` — аргументы для выполнения программы.

Сервер возвращает JSON с идентификатором задачи:
```json
{"id": "fb85a3a0-7e7f-4a20-8ced-65b3b2475144"}
```

Этот ID можно использовать для отслеживания статуса и получения результата выполнения задачи.

#### Получение статуса задачи

Клиенты могут отправить HTTP GET запрос на `/get_status` с телом:

```json
{"id": "fb85a3a0-7e7f-4a20-8ced-65b3b2475144"}
```

где id — это идентификатор задачи, полученный ранее. Сервер вернет ответ:

```json
{"status": "WAIT/RUNNING/SUCCESS/ERROR", "meta": {"created_at": "2024-11-10 00:00:00Z", "started_at": "2024-11-10 00:00:00Z", "finished_at": "2024-11-10 00:00:00Z"}, "result": {"stdout": "...", "stderr": "..."}}
```
- `status` — текущий статус задачи: WAIT (в очереди), RUNNING (выполняется), SUCCESS (завершена успешно), ERROR (ошибка).
- `meta` — вложенный JSON с информацией о времени создания, запуска и завершения задачи.
  - `created_at` — присутствует всегда и указывает, когда задача была создана.
  - `started_at` — присутствует только если состояние задачи RUNNING, SUCCESS или ERROR, и указывает, когда задача была запущена.
  - `finished_at` — присутствует только если задача завершена, т.е. статус SUCCESS или ERROR.
- `result` — вложенный JSON с результатами выполнения, содержащий stdout для успешного завершения или stderr в случае ошибки.
  - `stdout` — содержит вывод задачи при успешном выполнении.
  - `stderr` — появляется дополнительно к stdout, если задача завершилась с ошибкой.

#### Получение информации о количестве задач

При отправке HTTP GET запроса на /get_task_count сервер вернет текущее количество задач в очереди:

```json
{"tasks": 14}
```

## Интерфейс

При запуске сервера укажите три параметра: количество потоков (worker), адрес и порт, по которому сервер будет ожидать HTTP-соединения от клиентов:

```
./task_solver --workers 8 --address 127.0.0.1 --port 8080
```

## Усложненная версия

Чтобы получить дополнительный балл за курс, вам необходимо реализовать весь функционал проекта на асинхронных функциях, с помощью рантайма [tokio](https://tokio.rs/).

Поскольку у сервера может быть довольно много подключенных клиентов, создавать поток на каждое соединение накладно, а значит асинхронный рантайм будет очень кстати!

Подборка статей на эту тему, с которыми имеет смысл ознакомиться:

- https://tokio.rs/tokio/tutorial/hello-tokio
- https://hackmd.io/@cocoyoon/r1tsZX5vj
- https://medium.com/go-rust/rust-day-7-tokio-simple-tcp-server-32c40f12e79b

**Для базовой версии достаточно использования стандартных потоков и каналов.**

## Сторонние крейты

Аналогично первому проекту, вы можете использовать любые сторонние крейты. 

## Тесты

Вам нужно написать юнит тесты для тех функций, которые можно протестировать таким образом. И написать интеграционные тесты для проверки функционала всей программы в целом.

## Документация

Для каждой структуры и ее публичных методов необходимо написать комментарий с документацией и примерами как работать со структурой/методом.

## Codestyle

В дополнение к существующему общепринятому codestyle, вводятся следующие правила:

- Ограничение на нейминг:
    - Запрещаются любые однобуквенные переменные кроме i и j
    - Запрещаются любые сокращения в названиях, нужно писать слова полностью: fl → file, dir → directory, cmd → command
    - Запрещаются любые абстрактные названия, по которым непонятно что лежит в переменной. Вроде index, string, map, value, etc
- Ограничения на длину:
    - Длина любой строки не должна быть больше 120 символов
    - Длина любого файла без учета тестов не должна быть больше 120 строчек
    - Длина любой функции не должна быть больше 60и строчек
- Комментарии:
    - Все документирующие комментарии должны быть на английском языке
    - Запрещаются какие-либо другие комментарии, кроме документирующих

## Вспомогательные инструменты

В главном репозитории есть бинарный крейт tools/task_solver_client.

С их помощью можно удобно проверять работу вашего сервера решения задач:

1. Запустите ваш сервер

2. С помощью task_solver_client загрузите задачу в ваш сервер

```
cargo run -- create-task --address 127.0.0.1 --port 8080 --file-path /path/to/file --task-type bin --args "..."
```

3. Проверьте статус задачи

```
cargo run -- get-status --address 127.0.0.1 --port 8080 --id fb85a3a0-7e7f-4a20-8ced-65b3b2475144 
```

4. Проверьте количество задач на сервере

```
cargo run --get-task-count --address 127.0.0.1 --port 8080
```

## Сдача проекта

Код с проектом нужно хранить в своем GitHub репозитории, в папке **problems/projects/tasksolver**.

Перед отправкой решения крайне рекомендуется запустить `cargo fmt` и починить варнинги компиляции.

Изменения нужно пушить в ветку `projects/tasksolver`. Это делается аналогично регулярным задачам:

```
# в директории problems/projects/tasksolver
$ git add .  # добавляем все измененные файлы в индекс
$ git commit -m "your message"  # коммитим изменения
$ git push --force origin HEAD:projects/tasksolver  # пушим коммиты на сервер в ветку своего repo
```

Дальше, чтобы начать ревью (без прохождения ревью вы не получите баллы), нужно создать **Pull Request этой ветки в ветку main вашего репозитория**.

После создания пулл реквеста, нужно запросить ревью у одного из трех проверяющих:
- Даниил (tg: @dshindov)
- Ислам (tg: @lishy2)
- Санан (tg: @hac4erman)

**Запрашивать ревью можно не чаще чем раз в три дня.**

## Формула оценки

- За полностью реализованный функционал получите +4 балла
- За хороший дизайн системы и кодстайл (по нашему субъективному мнению) вы получите еще +3 балла
- За хорошие юнит и интеграционные тесты вы получите еще +2 балла
- За документацию ко всем базовым сущностям в вашем коде и хороший `--help` вы получите еще +1 балл
  - [The Rust Book: Making Useful Documentation Comments](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments)
  - [Rust By Example: Documentation](https://doc.rust-lang.org/stable/rust-by-example/meta/doc.html)
  - [rustdoc (cargo doc)](https://doc.rust-lang.org/stable/rustdoc/)
  - [Guide on how to write documentation for a Rust crate](https://blog.guillaume-gomez.fr/articles/2020-03-12+Guide+on+how+to+write+documentation+for+a+Rust+crate)
- За реализацию функционала через асинхронный рантайм, вы получите дополнительный балл за весь курс.

## Дедлайны

Сдавать проект на ревью можно начиная с утра 18-го ноября.

Один единственный жесткий дедлайн проекта -- конец курса.
